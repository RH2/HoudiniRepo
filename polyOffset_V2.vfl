//HEADER: CurveExpand
//customFunctions
	float clampAngle(float inputAngle){
    float x = inputAngle/3.14159265;
    x=x%2;
    if(x>1){
        x=-1+(x%1);
    }
    if(x<-1){
        x=1+(x%1);
    }
    x = x*3.14159265;
    return x;
	}
	void mergeArray(int array1[];int array2[]){
        foreach(int a2; array2){
                if(find(array1,a2)<0){
                        push(array1, a2);
                }
        }
	}
	float angleBetweenVectors2(vector a; vector b){
        a = normalize(a*{1,0,1});
        b = normalize(b*{1,0,1});
        vector c = normalize(a+b);

        float result = atan2(c[2],c[0]);
        return(result);
	}
	float sideCheckXZ(vector s; vector e; vector p){ //+=left
        float result = (e[0]-s[0])*(p[2]-s[2])  -  (e[2]-s[2])*(p[0]-s[0]);
        return result;
	}
	int I_result[];		void Specialdecode1(int i; string S_input; int output[]){
    output = {};
    string L[] = split(S_input,"L");
    if(i>len(L)-1){output = {-1};}
    string splits[] = split(L[i],",");
    //encode to integer array
    foreach(string s; splits){
        push(output, atoi(s));
    }
	} 
	string ftoa(float in){
    return sprintf("%.10f", in);
	}
	void addIntegerToStringSet(int i; string Set){
	int intarray[];
	string splits[] = split(Set, ",");
	if 
	foreach(string s; splits){
		push(intarray,atoi(s));
	}
	if(find(intarray,i)<0){
		if(Set[-1]!=","){Set+=","};
		Set+=itoa(i);
	}
	}
//constants
	float diameter = 50.0;
	float radius = diameter/2;
	float pi = 3.14159264;
	float tau = 3.14159264*2;


int originalJunctions[];
//record points with more than 3 neighbours
for(int nCheck=0; nCheck<npoints(0);nCheck++){
	if(neighbourcount(0,nCheck)>2){
		push(originalJunctions,nCheck);
	}
}

int pointsTooClose[]; //AKA DONOTSWEEP
//mark points based on proximity to all 3+ intersections
for(int pProxCheck=0; pProxCheck<npoints(0);pProxCheck++){
		vector locA = point(0,"P",pProxCheck);
		for(int junc=0;junc<len(originalJunctions);junc++){
			vector locB =point(0,"P",originalJunctions[junc]);
			locB = locA-locB;
			float dist = distance(locB);
			if(dist<radius){
				push(pointsTooClose,pProxCheck);
				break;//only needs to be marked once.
			} 
		}
}

int pointlessPrims[];
//mark primitives active or inactve
for(int pPrimCheck=0;pPrimCheck<nprimitives(0);pPrimCheck++){
	int numberOfActivePoints = 0;
	int pPoints[] = primpoints(0,pPrimCheck);
	for(int pp=0;pp<len(pPoints);pp++){
		if(find(pointsTooClose,pp)<0){
			numberOfActivePoints++;//if point is not found, then it is active
			break;//stop searching after first one is found.
		}
	}
	if(numberOfActivePoints==0){
		push(pointlessPrims,pPrimCheck);//if prim has any active points, then it is active.
	}
}

//limit scope
int specialIntersections[];
string reg[];//regular //primitive indice that needs new meta.
string rem[];//remove  //primitives that will no longer exist.
for(int j=0;j<len(originalJunctions);j++){//each junction
	int thisJunction = originalJunctions[j];
	int theseNeighbours[] = neighbours(0,thisJunction);//each point connected to junction.
	for(int jn=0;jn<len(theseNeighbours);jn++){
		int thisNeighbour = theseNeighbours[jn];
		int connectedPrims[] = pointprims(0,thisNeighbour);//only junctions have multiple prims.
		for(int withP=0;withP<len(connectedPrims);withP++){
			int thisConnectedPrim = connectedPrims[withP];
			if(find(pointlessPrims,thisConnectedPrim)>-1){//if branch is found in pointless
				if(find(specialIntersections,thisJunction)<0){
					push(specialIntersections,thisJunction);
				}
				rem += itoa(thisConnectedPrim)+",";
			}
			else{//branch is not pointless
				reg += itoa(thisConnectedPrim)+",";
			}
		}
	}
}

// sharesSimple is an array of all pointless prim sets.
//2 questions.
//	1.does this pointless prim exist in a share? 
//		yes: break. (optimization)
//		no : next question...
//			2. BURN PROCESS. Find all adjacent pointless siblings. and create+assign to new share.
string sharesSimple[]={""}; //Pointless primitive sets.  EG: "{1,2,8,54","101,102,103"} < pointlessprims that share starts or ends with or more of each other. 
foreach(int i=0;i<len(pointlessPrims);i++){
	int edge = pointlessPrims[i];
	string s_edge = ","+itoa(edge)+",";
	for(int n=0;n<len(sharesSimple);n++){//need to ask question in all sets.
		int findResult = find(sharesSimple[n]),s_edge));
		//Q1 : does this pointless prim exist in a share?
		if(findResult>-1){
			//Q1.yes!
			break;
		}
		else{
			//We will be creating a new share, because all adjacents will be gathered in one go!
			int newPrims[];	push(newPrims,edge); // < initially only has this edge, records edges/prims that are connected to current.
			int processedPrims[];  //flag. do not process primitives 
			int processedPoints[]; //flag. do not process points

			//THIS IS A BURN. We continue until no adjacent (POINTLESS)edges are found 
			int NewEdgesFound =1;
			while(NewEdgesFound>0){
				for(int cp = 0; cp<len(newPrims); cp++){
					checkPrim = newPrims[cp];
					if(find(processedPrims,checkPrim)<0){//only process if not found.
						push(processedPrims, checkPrim);//do not process this prim again.
						int rawPoints[] = primpoints(0,checkPrim);//get first and last point.	
						int initialEdges[]={};
						int endEdges[]={};
						if(find(processedPoints,rawPoints[0])<0){	//if not processed
							initialEdges = pointprims(0,rawPoints[0]); //get connecting edges.
							push(processedPoints,rawPoints[0]);
						}
						if(find(processedPoints,rawPoints[-1])<0){	//if not processed
							endEdges = pointprims(0,rawPoints[-1]);	//get connecting edges.
							push(processedPoints,rawPoints[-1]);
						}
						//cocatinate pointless.
						int connectedPointlessEdges[];
						NewEdgesFound = 0;
						foreach(int iEdge; initialEdges){
							if(find(pointlessPrims, iEdge)>-1&&find(processedPrims, iEdge)<0&&find(newPrims, iEdge)<0){ //if not processed, if not in newprim, and pointless.
								push(newPrims,iEdge);
								NewEdgesFound+=1;
							}
						}
						foreach(int eEdge; endEdges){
							if(find(pointlessPrims, eEdge)>-1&&find(processedPrims, eEdge)<0&&find(newPrims, eEdge)<0){ //if not processed, if not in newprim, and pointless.
								push(newPrims,eEdge);
								NewEdgesFound+=1;
							}
						}
					}
				}
			}
			//convert newPrim integer array to string for storage.
			string S_newShare = ","
			for(int p; newPrims){
				S_newShare+=itoa(p)+",";
			}
			push(sharesSimple,S_newShare);
		}
	}
}


//TODO: get sharepoints  
string sharePrims[];		//for each group of edges, there will be a group of *non removed* edges connected (PRIMS!).
string shareDirection[]; //1=out, 0=in // maps to the above.
string firstValidPoint[]; //walk edge until first usable point.	(POINTS!)

foreach(string oneSimpleShare; sharesSimple){ //for each collection of edges/primitives
	string output 					= ",";
	string directionoutput  = ",";
	string firstValid 			= ",";
	int sharePointProcessedPrims[];	//keep track of prims that have been processed.


	string thisShareSplit[] = split(oneSimpleShare,",");  // {J1,J2,J3,J4}
	int I_removablePrimitiveInShare[];
	for(string s; thisShareSplit){
		push(I_removablePrimitiveInShare, atoi(s));
	}
	//Get end and start of each split
	for(int rpis=0;rpis<len(I_removablePrimitiveInShare);rpis++){ //rpis = abbriviation for "removable prim in share"
		int i_removablePrm = I_removablePrimitiveInShare[rpis];
		int rawpoints[] = primpoints(0,i_removablePrm); //all points in prim.
		int end1 = rawpoints[0]; 
		int end2 = rawpoints[-1];
		int ends[];push(ends,end1);push(ends,end2)
		int allConnectedPrims[] = pointprims(0,end1);
		int otherPrims[] = pointprims(0,end2);

		//Make THESEPRIMS a list of all connected primitives/edges!
		for(int p2, otherPrims){
			push(allConnectedPrims,p2);
		}

		for(int sp=0;sp<len(allConnectedPrims);sp++){// sp = abbriviation for "selected prim"
			thisprim= allConnectedPrims[sp];
			//Is this prim regular? (not to be removed?) && does this prim exist in processedPrims?
			if(find(sharePointProcessedPrims,thisprim)<0&&find(pointlessPrims,thisprim)<0){
				push(sharePointProcessedPrims,thisprim);//don't process again.
				output= output + itoa(thisprim) +",";
				//Where is this point on this prim, initial or terminal? // for direction
				//How to solve: get first point of primitive, if first point equals current end. shareDirection = True = 1 = out;
				int thisPrimsPoints[] = primpoints(0,thisprim);
				int FirstPoint = thisPrimsPoints[0];
				if(find(ends, FirstPoint)>-1){
					directionoutput = directionoutput + "1,";
					//get first valid point
					for(int pointwalk=1;pointwalk<len(thisPrimsPoints);pointwalk++){ //direction is 1 so walk from 0, ++. ALSO! 0 is a junction, so start at 1.
						thisPNT = thisPrimsPoints[pointwalk];
						if(find(pointsTooClose,thisPNT)<0){ //if not found AKA not too close.
							firstValid= firstValid + itoa(thisPNT)+",";
							break;
						}
					}
				}else{//end1 != ppointFirst 
					directionoutput = directionoutput + "0,";
					//get first valid point
					for(int pointwalk= len(thisPrimsPoints)-2;pointwalk>=0;pointwalk--){ //direction is 0 so walk from MAX, --. ALSO! last is a junction, so start at -2.
						thisPNT = thisPrimsPoints[pointwalk];
						if(find(pointsTooClose,thisPNT)<0){ //if not found AKA not too close.
							firstValid= firstValid + itoa(thisPNT)+",";
							break;
						}
					}
				}
			}
		}
	push(sharePrims,			output);
	push(shareDirection,	directionoutput);
	push(firstValidPoint,	firstValid);
	}
}

//calc new location.
vector V_shareLoc[];
foreach(string oneSimpleShare; sharesSimple){
	// HAVING A POINT RECORDED MANY TIMES IS ***GOOD***. EMERGENT WEIGHTS.
	string S_edges = split(oneSimpleShare, ",");
	int I_edges[];
	int JunctionPoints[];
	foreach(string item; S_edges){
		push(I_edges, atoi(item));
	}
	foreach(int edgeindex; I_edges){
		int rawpoints[] = primpoints(0,edgeindex);
		int e0 = rawpoints[0];
		int e1 = rawpoints[-1];
		push(JunctionPoints,e0);
		push(JunctionPoints,e1);	
	}
	vector newLoc;
	//sum position for all points
	foreach(int point; JunctionPoints){
		vector loc = point(0,"P",point);
		newLoc+=loc;
	}

	newLoc = newLoc/len(JunctionPoints); //AVERAGE
	push(V_shareLoc,newLoc);
}


//Calculate UV Offset. Will need flow direction for +/- multiplier.

//get valid point
//get direction
//get prim

//get beginning or end based on direction
//calculate location difference as float offset.
//store floats in a string array.

string offsets[]; // uv offset for first valid point.
for(int k=0; k<len(sharePrims);k++){
	string offsetCollection = ",";

	string S_thisPrimSet = sharePrims[k];
	string S_thisDirections = shareDirection[k];
	string S_theseClosePoints =  firstValidPoint[k];
	//convert these strings to integer arrays.
	int I_thesePrims[];					foreach(string x;S_thisPrimSet)			{push(I_thesePrims,				atoi(x)	)};	
	int I_theseDirections[];		foreach(string x;S_thisDirections)	{push(I_theseDirections,	atoi(x)	)};
	int I_theseClosePoints[];		foreach(string x;S_theseClosePoints){push(I_theseClosePoints,	atoi(x)	)};

	//all of these arrays should be 1:1
	for(int x = 0; x<len(I_thesePrims);x++){
		int edg = I_thesePrims[x];
		int edgpnts[] = primpoints(0,edg);
		int dir = I_theseDirections[x];
		int pnt = I_theseClosePoints[x];

		vector thisLoc = point(0,"P",pnt);
		vector newLoc = V_shareLoc[k];
		vector originalLoc;  
		if(dir==1){originalLoc = point(0,"P",edgpnts[0]);}else{originalLoc = point(0,"P",edgpnts[-1])};


		float od = distance(thisLoc,oldLoc); 
		float nd = distance(thisLoc,newLoc);
		float dd = nd-od;

		string dd_stringified = ftoa(dd);
		offsetCollection += dd_stringified+",";
	}
}

//offset source uv happens when we sweep the curve.
//offset junction happens when we expand the junction.


//SWEEP --LETS DO THIS.

//start at prim level...
for(int currentPrim;currentPrim<len(nprimitives(0);currentPrim++){					//FOR ALL PRIMITIVES.
	if(find(pointlessPrims,currentPrim)<0){ //if not pointless.								//IF NOT POINTLESS (first optimization.)
		//special case if it is inflow from share.
		//attempt to find in share with direction==1;
		for(int oneShare=0;oneShare<len(sharesSimple);oneShare++){							//EVALUATE IF PRIMITIVE IS IN INFLOW, IF YES: OFFSET UVS.
			//convert to int array.
			string S_shareFrag[] = split(sharesSimple[oneShare],",");
			int I_convertedShares[];
			foreach(string ccs;S_shareFrag){push(I_convertedShares,atoi(ccs));}
			int searchResults[] = find(I_convertedShares,currentPrim);
			
			if(len(searchResults)>0){
				//expand direction storage.
				string S_dirFrag[] = split(shareDirection[oneShare],",");
				int I_dirs[];	foreach(string ds; S_dirFrag){push(I_dirs,atoi(ds));}
				foreach(int sr; searchResults){
					if(I_dirs[sr]==1){//offset uvs
						//get offset distance 
						float UVdelta[];foreach(string ofs; offsets){push(UVdelta,atof(ofs));}
						float thisUVdelta = UVdelta[sr];
						
						int thisPrimsPoints[] = primpoints(0,currentPrim);
						for(int processPoint =0; processPoint<len(thisPrimsPoints);processPoint++){
							int depoint=thisPrimsPoints[processPoint];
							//if(find(pointsTooClose,depoint)<0){
								vector originalUV = point(0,"uv",depoint);
								float newu= originalUV[0]+thisUVdelta;
								//modify uv and reassign
								vector newUV = set(newu, originalUV[1]);
								//set attribute
								int pass = setpointattrib(0,"uv,", depoint, newUV, "set");
							//}
						}
					}
				}
			}
		}
	}
}




//JUNCTION