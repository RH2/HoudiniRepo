//CUSTOMEXPAND
float clampAngle(float inputAngle){
    float x = inputAngle/3.14159265;
    x=x%2;
    if(x>1){
        x=-1+(x%1);
    }
    if(x<-1){
        x=1+(x%1);
    }
    x = x*3.14159265;
    return x;
}
void mergeArray(int array1[];int array2[]){
        foreach(int a2; array2){
                if(find(array1,a2)<0){
                        push(array1, a2);
                }
        }
}
float angleBetweenVectors2(vector a; vector b){
        a = normalize(a*{1,0,1});
        b = normalize(b*{1,0,1});
        vector c = normalize(a+b);

        float result = atan2(c[2],c[0]);
        return(result);
}
float sidecheckXZ(vector s; vector e; vector p){ //+=left
        float result = (e[0]-s[0])*(p[2]-s[2])  -  (e[2]-s[2])*(p[0]-s[0]);
        return result;
}

float diameter = 50.0;
float radius = diameter/2;
float pi = 3.14159264;
float tau = 3.14159264*2;


int originalJunctions[];
//record points with more than 3 neighbours
for(int nCheck=0; nCheck<npoints(0);nCheck++){
	if(neighbourcount(0,nCheck)>2){
		push(originalJunctions,nCheck);
	}
}

int pointsTooClose[]; //AKA DONOTSWEEP
//mark points based on proximity to all 3+ intersections
for(int pProxCheck=0; pProxCheck<npoints(0);pProxCheck++){
		vector locA = point(0,"P",pProxCheck);
		for(int junc=0;junc<len(originalJunctions);junc++){
			vector locB =point(0,"P",originalJunctions[junc]);
			locB = locA-locB;
			float dist = distance(locB);
			if(dist<radius){
				push(pointsTooClose,pProxCheck);
				break;//only needs to be marked once.
			} 
		}
}

int pointlessPrims[];
//mark primitives active or inactve
for(int pPrimCheck=0;pPrimCheck<nprimitives(0);pPrimCheck++){
	int numberOfActivePoints = 0;
	int pPoints[] = primpoints(0,pPrimCheck);
	for(int pp=0;pp<len(pPoints);pp++){
		if(find(pointsTooClose,pp)<0){
			numberOfActivePoints++;//if point is not found, then it is active
			break;//stop searching after first one is found.
		}
	}
	if(numberOfActivePoints==0){
		push(pointlessPrims,pPrimCheck);//if prim has any active points, then it is active.
	}
}

//build new metajunctions from existing junctions.
//build set of junctions based on adjacent pointless primitives.

//ATTEMPT1
//create two sets for each intersection family.
	//int branchActive[];
	//int branchInactive[];
	//for(int oj=0;oj<len(originalJunctions);oj++){
	//	int thisOriginalJunction = originalJunctions[oj];
	//	int connected[] = pointprims(0, thisOriginalJunction);
	//	for(int cc=0; cc<len(connected); cc++){
	//		int thisConnection = connected[cc];
	//		if(find(pointlessPrims,thisConnection)>-1){
	//			if(find(branchInactive,thisConnection)>-1){push(branchInactive,thisConnection);}
	//		}
	//		else{
	//			if(find(branchActive,thisConnection)>-1){push(branchActive,thisConnection);}
	//		}
	//	}
	//	for(int de=0; de<len(branchInactive);de++){
	//
	//	}
	//}

//ATTEMPT2

//Create a list of pointlessPrimitives that touch.
	//get list of pointlessprimitives
	//get first and last point (first and last can be the same)
	//

