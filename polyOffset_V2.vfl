//CUSTOMEXPAND
float clampAngle(float inputAngle){
    float x = inputAngle/3.14159265;
    x=x%2;
    if(x>1){
        x=-1+(x%1);
    }
    if(x<-1){
        x=1+(x%1);
    }
    x = x*3.14159265;
    return x;
}
void mergeArray(int array1[];int array2[]){
        foreach(int a2; array2){
                if(find(array1,a2)<0){
                        push(array1, a2);
                }
        }
}
float angleBetweenVectors2(vector a; vector b){
        a = normalize(a*{1,0,1});
        b = normalize(b*{1,0,1});
        vector c = normalize(a+b);

        float result = atan2(c[2],c[0]);
        return(result);
}
float sideCheckXZ(vector s; vector e; vector p){ //+=left
        float result = (e[0]-s[0])*(p[2]-s[2])  -  (e[2]-s[2])*(p[0]-s[0]);
        return result;
}

float diameter = 50.0;
float radius = diameter/2;
float pi = 3.14159264;
float tau = 3.14159264*2;


int originalJunctions[];
//record points with more than 3 neighbours
for(int nCheck=0; nCheck<npoints(0);nCheck++){
	if(neighbourcount(0,nCheck)>2){
		push(originalJunctions,nCheck);
	}
}

int pointsTooClose[]; //AKA DONOTSWEEP
//mark points based on proximity to all 3+ intersections
for(int pProxCheck=0; pProxCheck<npoints(0);pProxCheck++){
		vector locA = point(0,"P",pProxCheck);
		for(int junc=0;junc<len(originalJunctions);junc++){
			vector locB =point(0,"P",originalJunctions[junc]);
			locB = locA-locB;
			float dist = distance(locB);
			if(dist<radius){
				push(pointsTooClose,pProxCheck);
				break;//only needs to be marked once.
			} 
		}
}

int pointlessPrims[];
//mark primitives active or inactve
for(int pPrimCheck=0;pPrimCheck<nprimitives(0);pPrimCheck++){
	int numberOfActivePoints = 0;
	int pPoints[] = primpoints(0,pPrimCheck);
	for(int pp=0;pp<len(pPoints);pp++){
		if(find(pointsTooClose,pp)<0){
			numberOfActivePoints++;//if point is not found, then it is active
			break;//stop searching after first one is found.
		}
	}
	if(numberOfActivePoints==0){
		push(pointlessPrims,pPrimCheck);//if prim has any active points, then it is active.
	}
}

//limit scope
int specialIntersections[];
string reg[];//regular //primitive indice that needs new meta.
string rem[];//remove  //primitives that will no longer exist.
for(int j=0;j<len(originalJunctions);j++){//each junction
	int thisJunction = originalJunctions[j];
	int theseNeighbours[] = neighbours(0,thisJunction);//each point connected to junction.
	for(int jn=0;jn<len(theseNeighbours);jn++){
		int thisNeighbour = theseNeighbours[jn];
		int connectedPrims[] = pointprims(0,thisNeighbour);//only junctions have multiple prims.
		for(int withP=0;withP<len(connectedPrims);withP++){
			int thisConnectedPrim = connectedPrims[withP];
			if(find(pointlessPrims,thisConnectedPrim)>-1){//if branch is found in pointless
				if(find(specialIntersections,thisJunction)<0){
					push(specialIntersections,thisJunction);
				}
				rem += itoa(thisConnectedPrim)+",";
			}
			else{//branch is not pointless
				reg += itoa(thisConnectedPrim)+",";
			}
		}
	}
}

string shares[]; //UNUSED //"N","metaLocIndex","branchPrimIndex",...
vector metaLoc[];//UNUSED //

//foreach special intersection (steps 5,6,7)
	//1. dynamic group based on matching rems
	//2. union reg
	//3. connecting point?
	//4. location
	//5. uv difference

for(int si=0; si<len(specialIntersections);si++){ //EVERY POINTLESS POLY USUALLY HAS TWO JUNCTIONS.
	int thisSpecialIntersection = specialIntersections[si];//for each sepcial intersection
	string thisReg[] = split(reg[si],",");
	string thisRem[] = split(rem[si],",");
	int I_thisReg[];
	int I_thisRem[];
	//convert reg and rem to integer arrays
	for(int regindex = 0; regindex<len(thisReg);regindex++){
		push(I_thisReg, atoi(thisReg[regindex]));
	}
	for(int remindex = 0; remindex<len(thisRem);remindex++){
		push(I_thisRem, atoi(thisRem[remindex]));
	}

	//compare against all other special intersections (N-next to N-term).
	for(int oi=si+1; oi<len(specialIntersections);oi++){
		string otherReg[] = split(reg[oi],",");
		string otherRem[] = split(rem[oi],",");
		int I_otherReg[];
		int I_otherRem[];
		//convert reg and rem to integer arrays
		for(int regindex = 0; regindex<len(otherReg);regindex++){
			push(I_otherReg, atoi(otherReg[regindex]));
		}
		for(int remindex = 0; remindex<len(otherRem);remindex++){
			push(I_thisRem, atoi(otherRem[remindex]));
		}
	}


	//when we find another junction, sharing one of the rems â€” we create a new junction and continue searching
	//At the end of the search, if the metajunction (shares[]) is empty, we do not push.






}














