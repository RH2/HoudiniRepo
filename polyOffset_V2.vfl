//HEADER: CurveExpand
//customFunctions
	float clampAngle(float inputAngle){
    float x = inputAngle/3.14159265;
    x=x%2;
    if(x>1){
        x=-1+(x%1);
    }
    if(x<-1){
        x=1+(x%1);
    }
    x = x*3.14159265;
    return x;
	}
	void mergeArray(int array1[];int array2[]){
        foreach(int a2; array2){
                if(find(array1,a2)<0){
                        push(array1, a2);
                }
        }
	}
	float angleBetweenVectors2(vector a; vector b){
        a = normalize(a*{1,0,1});
        b = normalize(b*{1,0,1});
        vector c = normalize(a+b);

        float result = atan2(c[2],c[0]);
        return(result);
	}
	float sideCheckXZ(vector s; vector e; vector p){ //+=left
        float result = (e[0]-s[0])*(p[2]-s[2])  -  (e[2]-s[2])*(p[0]-s[0]);
        return result;
	}
	int I_result[];		void Specialdecode1(int i; string S_input; int output[]){
    output = {};
    string L[] = split(S_input,"L");
    if(i>len(L)-1){output = {-1};}
    string splits[] = split(L[i],",");
    //encode to integer array
    foreach(string s; splits){
        push(output, atoi(s));
    }
	} 
	void addIntegerToStringSet(int i; string Set){
	int intarray[];
	string splits[] = split(Set, ",");
	if 
	foreach(string s; splits){
		push(intarray,atoi(s));
	}
	if(find(intarray,i)<0){
		if(Set[-1]!=","){Set+=","};
		Set+=itoa(i);
	}
	}
//constants
	float diameter = 50.0;
	float radius = diameter/2;
	float pi = 3.14159264;
	float tau = 3.14159264*2;


int originalJunctions[];
//record points with more than 3 neighbours
for(int nCheck=0; nCheck<npoints(0);nCheck++){
	if(neighbourcount(0,nCheck)>2){
		push(originalJunctions,nCheck);
	}
}

int pointsTooClose[]; //AKA DONOTSWEEP
//mark points based on proximity to all 3+ intersections
for(int pProxCheck=0; pProxCheck<npoints(0);pProxCheck++){
		vector locA = point(0,"P",pProxCheck);
		for(int junc=0;junc<len(originalJunctions);junc++){
			vector locB =point(0,"P",originalJunctions[junc]);
			locB = locA-locB;
			float dist = distance(locB);
			if(dist<radius){
				push(pointsTooClose,pProxCheck);
				break;//only needs to be marked once.
			} 
		}
}

int pointlessPrims[];
//mark primitives active or inactve
for(int pPrimCheck=0;pPrimCheck<nprimitives(0);pPrimCheck++){
	int numberOfActivePoints = 0;
	int pPoints[] = primpoints(0,pPrimCheck);
	for(int pp=0;pp<len(pPoints);pp++){
		if(find(pointsTooClose,pp)<0){
			numberOfActivePoints++;//if point is not found, then it is active
			break;//stop searching after first one is found.
		}
	}
	if(numberOfActivePoints==0){
		push(pointlessPrims,pPrimCheck);//if prim has any active points, then it is active.
	}
}

//limit scope
int specialIntersections[];
string reg[];//regular //primitive indice that needs new meta.
string rem[];//remove  //primitives that will no longer exist.
//string SB_regS[];//STRING BOOL, is this point a source?
//string SB_remS[];//STRING BOOL, is this point a source?
for(int j=0;j<len(originalJunctions);j++){//each junction
	int thisJunction = originalJunctions[j];
	int theseNeighbours[] = neighbours(0,thisJunction);//each point connected to junction.
	for(int jn=0;jn<len(theseNeighbours);jn++){
		int thisNeighbour = theseNeighbours[jn];
		int connectedPrims[] = pointprims(0,thisNeighbour);//only junctions have multiple prims.
		for(int withP=0;withP<len(connectedPrims);withP++){
			int thisConnectedPrim = connectedPrims[withP];
			if(find(pointlessPrims,thisConnectedPrim)>-1){//if branch is found in pointless
				if(find(specialIntersections,thisJunction)<0){
					push(specialIntersections,thisJunction);
				}
				rem += itoa(thisConnectedPrim)+",";
			}
			else{//branch is not pointless
				reg += itoa(thisConnectedPrim)+",";
			}
		}
	}
}

// sharesSimple is an array of all pointless prim sets.
//2 questions.
//	1.does this pointless prim exist in a share? 
//		yes: break. (optimization)
//		no : next question...
//			2. BURN PROCESS. Find all adjacent pointless siblings. and create+assign to new share.
string sharesSimple[]={""}; //Jpoint sets.  EG: "{1,2,8,54","101,102,103"} < pointlessprims that share starts or ends with or more of each other. 
foreach(int i=0;i<len(pointlessPrims);i++){
	int edge = pointlessPrims[i];
	string s_edge = ","+itoa(edge)+",";
	for(int n=0;n<len(sharesSimple);n++){//need to ask question in all sets.
		int findResult = find(sharesSimple[n]),s_edge));
		//Q1 : does this pointless prim exist in a share?
		if(findResult>-1){
			//Q1.yes!
			break;
		}
		else{
			//We will be creating a new share, because all adjacents will be gathered in one go!
			int newPrims[];	push(newPrims,edge); // < initially only has this edge, records edges/prims that are connected to current.
			int processedPrims[];  //flag. do not process primitives 
			int processedPoints[]; //flag. do not process points

			//THIS IS A BURN. We continue until no adjacent (POINTLESS)edges are found 
			int NewEdgesFound =1;
			while(NewEdgesFound>0){
				for(int cp = 0; cp<len(newPrims); cp++){
					checkPrim = newPrims[cp];
					if(find(processedPrims,checkPrim)<0){//only process if not found.
						push(processedPrims, checkPrim);//do not process this prim again.
						int rawPoints[] = primpoints(0,checkPrim);//get first and last point.	
						int initialEdges[]={};
						int endEdges[]={};
						if(find(processedPoints,rawPoints[0])<0){	//if not processed
							initialEdges = pointprims(0,rawPoints[0]); //get connecting edges.
							push(processedPoints,rawPoints[0]);
						}
						if(find(processedPoints,rawPoints[-1])<0){	//if not processed
							endEdges = pointprims(0,rawPoints[-1]);	//get connecting edges.
							push(processedPoints,rawPoints[-1]);
						}
						//cocatinate pointless.
						int connectedPointlessEdges[];
						NewEdgesFound = 0;
						foreach(int iEdge; initialEdges){
							if(find(pointlessPrims, iEdge)>-1&&find(processedPrims, iEdge)<0&&find(newPrims, iEdge)<0){ //if not processed, if not in newprim, and pointless.
								push(newPrims,iEdge);
								NewEdgesFound+=1;
							}
						}
						foreach(int eEdge; endEdges){
							if(find(pointlessPrims, eEdge)>-1&&find(processedPrims, eEdge)<0&&find(newPrims, eEdge)<0){ //if not processed, if not in newprim, and pointless.
								push(newPrims,eEdge);
								NewEdgesFound+=1;
							}
						}
					}
				}
			}
			//convert newPrim integer array to string for storage.
			string S_newShare = ","
			for(int p; newPrims){
				S_newShare+=itoa(p)+",";
			}
			push(sharesSimple,S_newShare);
		}
	}
}





//TODO: get sharepoints
string sharePoints[];
string shareDirection[]; //1=out, 0=in // maps to the above.
string firstValidPoint[]; //walk edge until first usable point.

foreach(string share; sharesSimple){
	string output 					= ",";
	string directionoutput  = ",";
	string firstValid 			= ",";

	int sharePointProcessedPrims[];
	string splits[] = split(share,",");
	int i_splits[];
	for(string s; splits){
		push(i_splits, atoi(s));
	}
	//Get end and start of each split
	for(string splice; splits){
		i_splice = atoi(splice);
		int rawpoints[] = primpoints(0,i_splice);
		int end1 = rawpoints[0]; 
		int end2 = rawpoints[-1];
		int thesePrims[] = pointprims(0,start);
		int additialPrims[] = pointprims(0,end);

		//combine these prim arrays.
		for(int p2, additialPrims){
			push(thesePrims,p2);
		}

		for(int sp=0;sp<len(thesePrims);sp++){
			thisprim= thesePrims[sp];
			//Is this prim regular? (not to be removed?) && does this prim exist in processedPrims?
			if(find(sharePointProcessedPrims,thisprim)<0&&find(pointlessPrims,thisprim)<0){
				push(sharePointProcessedPrims,thisprim);
				output= output + itoa(i_splice) +",";
				//Where is this point on this prim, initial or terminal? // for direction
				//How to solve: get first point of primitive, if first point equals current end. shareDirection = True = 1 = out;
				int ppoints[] = primpoints(0,thisprim);
				int ppointFirst = ppoints[0];
				if(end1 = ppointFirst){
					directionoutput = directionoutput + "1,";
					//get first valid point
					for(int pointwalk=1;pointwalk<len(ppoints);pointwalk++){ //direction is 1 so walk from 0, ++. ALSO! 0 is a junction, so start at 1.
						thisPNT = ppoints[pointwalk];
						if(find(pointsTooClose,thisPNT)<0){ //if not found AKA not too close.
							firstValid= firstValid + itoa(thisPNT)+",";
							break;
						}
					}
				}else{//end1 != ppointFirst 
					directionoutput = directionoutput + "0,";
					//get first valid point
					for(int pointwalk= len(ppoints)-2;pointwalk>=0;pointwalk--){ //direction is 0 so walk from MAX, --. ALSO! last is a junction, so start at -2.
						thisPNT = ppoints[pointwalk];
						if(find(pointsTooClose,thisPNT)<0){ //if not found AKA not too close.
							firstValid= firstValid + itoa(thisPNT)+",";
							break;
						}
					}
				}
			}
		}
	push(sharePoints,			output);
	push(shareDirection,	directionoutput);
	push(firstValidPoint,	firstValid);
	}
}

//TODO: get distance to sharePosition











//TODO: Calculate UV Offset. Will need flow direction for +/- multiplier.









