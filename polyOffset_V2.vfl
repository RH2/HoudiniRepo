//HEADER: CurveExpand
//customFunctions
	float clampAngle(float inputAngle){
    float x = inputAngle/3.14159265;
    x=x%2;
    if(x>1){
        x=-1+(x%1);
    }
    if(x<-1){
        x=1+(x%1);
    }
    x = x*3.14159265;
    return x;
	}
	void mergeArray(int array1[];int array2[]){
        foreach(int a2; array2){
                if(find(array1,a2)<0){
                        push(array1, a2);
                }
        }
	}
	float angleBetweenVectors2(vector a; vector b){
        a = normalize(a*{1,0,1});
        b = normalize(b*{1,0,1});
        vector c = normalize(a+b);

        float result = atan2(c[2],c[0]);
        return(result);
	}
	float sideCheckXZ(vector s; vector e; vector p){ //+=left
        float result = (e[0]-s[0])*(p[2]-s[2])  -  (e[2]-s[2])*(p[0]-s[0]);
        return result;
	}
	void Specialdecode1(int i; string S_input; int output[]){
    output = {};
    string L[] = split(S_input,"L");
    if(i>len(L)-1){output = {-1};}
    string splits[] = split(L[i],",");
    //encode to integer array
    foreach(string s; splits){
        push(output, atoi(s));
    }
	} 
	string ftoa(float in){
    return sprintf("%.10f", in);
	}
	void addIntegerToStringSet(int i; string Set){
		int intarray[];
		string splits[] = split(Set, ",");
		foreach(string s; splits){
			int convert = atoi(s);
			push(intarray,convert);
		}
		if(find(intarray,i)<0){
			if(Set[-1]!=","){Set+=",";}
			Set+=itoa(i);
		}
	}
//constants
	float diameter = 1.1;
	float radius = diameter/2;
	float pi = 3.14159264;
	float tau = 3.14159264*2;


int originalJunctions[];
//record points with more than 3 neighbours
for(int nCheck=0; nCheck<npoints(0);nCheck++){
	if(neighbourcount(0,nCheck)>2){
		push(originalJunctions,nCheck);
	}
}

int pointsTooClose[]; //AKA DONOTSWEEP
//mark points based on proximity to all 3+ intersections
for(int pProxCheck=0; pProxCheck<npoints(0);pProxCheck++){
		vector locA = point(0,"P",pProxCheck);
		for(int junc=0;junc<len(originalJunctions);junc++){
			vector locB =point(0,"P",originalJunctions[junc]);
			float dist = distance(locA,locB);
			if(dist<radius){
				push(pointsTooClose,pProxCheck);
				break;//only needs to be marked once.
			} 
		}
}

int pointlessPrims[];
//mark primitives active or inactve
for(int pPrimCheck=0;pPrimCheck<nprimitives(0);pPrimCheck++){
	int numberOfActivePoints = 0;
	int pPoints[] = primpoints(0,pPrimCheck);
	for(int pp=0;pp<len(pPoints);pp++){
		int focusedPoint = pPoints[pp];
		if(find(pointsTooClose,focusedPoint)<1){
			int nCount = neighbourcount(0,focusedPoint);
			if(nCount<3){//Check to see if is a junction.
				numberOfActivePoints++;//if point is not found, then it is active
				break;//stop searching after first one is found.
			}
		}
	}
	if(numberOfActivePoints==0){
		push(pointlessPrims,pPrimCheck);//if prim has any active points, then it is active.
	}
}

//limit scope
int specialIntersections[];
string reg[];//regular //primitive indice that needs new meta.
string rem[];//remove  //primitives that will no longer exist.
for(int j=0;j<len(originalJunctions);j++){//each junction
	push(reg,",");
	push(rem,",");
	int thisJunction = originalJunctions[j];
	int theseNeighbours[] = neighbours(0,thisJunction);//each point connected to junction.
	for(int jn=0;jn<len(theseNeighbours);jn++){
		int thisNeighbour = theseNeighbours[jn];
		int connectedPrims[] = pointprims(0,thisNeighbour);//only junctions have multiple prims.
		for(int withP=0;withP<len(connectedPrims);withP++){
			int thisConnectedPrim = connectedPrims[withP];
			if(find(pointlessPrims,thisConnectedPrim)>-1){//if branch is found in pointless
				if(find(specialIntersections,thisJunction)<0){
					push(specialIntersections,thisJunction);
				}
				rem[j] += itoa(thisConnectedPrim)+","; //possible error, correct array index?
			}
			else{//branch is not pointless
				reg[j] += itoa(thisConnectedPrim)+",";
			}
		}
	}
}

// sharesSimple is an array of all pointless prim sets.
	//2 questions.
	//	1.does this pointless prim exist in a share? 
	//		yes: break. (optimization)
	//		no : next question...
	//			2. BURN PROCESS. Find all adjacent pointless siblings. and create+assign to new share.
string sharesSimple[]; //Pointless primitive sets.  EG: "{1,2,8,54","101,102,103"} < pointlessprims that share starts or ends with or more of each other. 
for(int i=0;i<len(pointlessPrims);i++){
	int edge = pointlessPrims[i];
	string s_edge = ","+itoa(edge)+",";


	int findResultAllIndices = 0;
	foreach(string oneStringInSharesSimple; sharesSimple){
		if(find(oneStringInSharesSimple,s_edge)>-1){
			//if found
			findResultAllIndices=1;
			break;
		}
	}
	if(findResultAllIndices==0){//if not found, new entry needed
			//We will be creating a new share, because all adjacents will be gathered in one go!
			int newPrims[];	push(newPrims,edge); // < initially only has this edge, records edges/prims that are connected to current.
			int processedPrims[];  //flag. do not process primitives 
			int processedPoints[]; //flag. do not process points

			//THIS IS A BURN. We continue until no adjacent (POINTLESS)edges are found 
			int NewEdgesFound =1;
			while(NewEdgesFound>0){
				for(int cp = 0; cp<len(newPrims); cp++){
					int checkPrim = newPrims[cp];
					if(find(processedPrims,checkPrim)<0){//only process if not found.
						push(processedPrims, checkPrim);//do not process this prim again.
						int rawPoints[] = primpoints(0,checkPrim);//get first and last point.	
						int initialEdges[]={};
						int endEdges[]={};
						if(find(processedPoints,rawPoints[0])<0){	//if not processed
							initialEdges = pointprims(0,rawPoints[0]); //get connecting edges.
							push(processedPoints,rawPoints[0]);
						}
						if(find(processedPoints,rawPoints[-1])<0){	//if not processed
							endEdges = pointprims(0,rawPoints[-1]);	//get connecting edges.
							push(processedPoints,rawPoints[-1]);
						}
						//cocatinate pointless.
						int connectedPointlessEdges[];
						NewEdgesFound = 0;
						foreach(int iEdge; initialEdges){
							if(find(pointlessPrims, iEdge)>-1&&find(processedPrims, iEdge)<0&&find(newPrims, iEdge)<0){ //if not processed, if not in newprim, and pointless.
								push(newPrims,iEdge);
								NewEdgesFound+=1;
							}
						}
						foreach(int eEdge; endEdges){
							if(find(pointlessPrims, eEdge)>-1&&find(processedPrims, eEdge)<0&&find(newPrims, eEdge)<0){ //if not processed, if not in newprim, and pointless.
								push(newPrims,eEdge);
								NewEdgesFound+=1;
							}
						}
					}
				}
			}
			//convert newPrim integer array to string for storage.
			string S_newShare = ",";
			foreach(int p; newPrims){
				S_newShare+=itoa(p)+",";
			}
			push(sharesSimple,S_newShare); 
	}
}

//TODO: get sharepoints  
string sharePrims[];		//for each group of edges, there will be a group of *non removed* edges connected (PRIMS!).
string shareDirection[]; //1=out, 0=in // maps to the above.
string firstValidPoint[]; //walk edge until first usable point.	(POINTS!)

foreach(string oneSimpleShare; sharesSimple){ //for each collection of edges/primitives
	int I_output[];
	string output 					= ",";
	string directionoutput  = ",";
	string firstValid 			= ",";
	int sharePointProcessedPrims[];	//keep track of prims that have been processed.

	string thisShareSplit[] = split(oneSimpleShare,",");  //",4,5," pointless prims.
	int I_removablePrimitiveInShare[];
	foreach(string s; thisShareSplit){
		push(I_removablePrimitiveInShare, atoi(s));
	}
	//Get end and start of each split
	for(int rpis=0;rpis<len(I_removablePrimitiveInShare);rpis++){ //rpis = abbriviation for "removable prim in share"
		int i_removablePrm = I_removablePrimitiveInShare[rpis];
		int rawpoints[] = primpoints(0,i_removablePrm); //all points in prim.
		int end1 = rawpoints[0]; 
		int end2 = rawpoints[-1];
		int ends[];push(ends,end1);push(ends,end2);
		int allConnectedPrims[] = pointprims(0,end1);
		int otherPrims[] = pointprims(0,end2);
		foreach(int oneOtherPrim; otherPrims){
			push(allConnectedPrims,oneOtherPrim);
		} //ALLCONNECTEDPRIMS = all edges attached to this prim.

		for(int sp=0;sp<len(allConnectedPrims);sp++){// sp = abbriviation for "selected prim"
			int thisprim= allConnectedPrims[sp];
			//Is this prim regular? (not to be removed?) && does this prim exist in processedPrims?
			if(find(sharePointProcessedPrims,thisprim)<0&&find(pointlessPrims,thisprim)<0){
				push(sharePointProcessedPrims,thisprim);//don't process again.
				output= output + itoa(thisprim) +",";
				push(I_output,thisprim);
			}
		}
		if(rpis==len(I_removablePrimitiveInShare)-1){ //special checks on last loop, before submitting final answer.

			int extraOutput[];
			int extraPoints[];
			int extraDirections[];
			//for each of I_output, determine if endpoints exist in set.
			int I_output_cache[] = I_output;//cache output, because it will change.
			for(int i=0;i<len(I_output_cache);i++){
				int thisoutput = I_output_cache[i]; //one connected prim
				int thisoutputPoints[] = primpoints(0,thisoutput);
				int fpoint= thisoutputPoints[0];
				int tpoint= thisoutputPoints[-1]; 
	
				//all pointless ends.
				int pointlessEnds[];
				foreach(int pointlessEdge;I_removablePrimitiveInShare){
					int plends[] = primpoints(0,pointlessEdge);
					push(pointlessEnds,plends[0]);
					push(pointlessEnds,plends[-1]);
				}

				// original location // int extraOutput[];
				// original location // int extraPoints[];
				// original location // int extraDirections[];
				if(find(pointlessEnds,fpoint)>-1){//check if first point exists in junction. 
					foreach(int walkForwardPoint;thisoutputPoints){//walk to first valid point..
						if(find(pointsTooClose,walkForwardPoint)<0){//point is not too close.
							firstValid = firstValid + itoa(walkForwardPoint)+","; 
							directionoutput = directionoutput + "1,";
							//now we check to see if the end also belongs to this intersection.
							if(find(pointlessEnds,tpoint)>-1){//check to see if last point ALSO exists in junction. (loop detection)
								
								int reversedPoints[] = reverse(thisoutputPoints);
								foreach(int walkBackwardsPoint;reversedPoints){//walk reverse to first terminal that is valid
									if(find(pointsTooClose,walkBackwardsPoint)<0){//if not too close
										push(extraOutput, thisoutput);
										push(extraPoints, walkBackwardsPoint);
										push(extraDirections, 0);
										break;
									}
								}
							}
							break;
						}
					}
				}
				else if(find(pointlessEnds,tpoint)>-1){//else check if last point exists in junction.
					foreach(int walkBackwardsPoint;reverse(thisoutputPoints)){//walk backwards to first point that is valid.
						if(find(pointsTooClose,walkBackwardsPoint)<0){//point is not too close.
							firstValid = firstValid + itoa(walkBackwardsPoint)+","; 
							directionoutput = directionoutput + "0,";
							//no need to also check first, we already did.
							break;
						}
					}
				}

				//APPEND EXTRAS!
			}
			//append extras.
			foreach(int eO; extraOutput){
				output = output + itoa(eO)+",";
			}
			foreach(int eP; extraPoints){
				firstValid = firstValid + itoa(eP)+ ",";
			}
			foreach(int eD; extraDirections){
				directionoutput = directionoutput + itoa(eD)+ ",";
			}

			push(sharePrims,output);
			push(firstValidPoint,	firstValid);
			push(shareDirection,	directionoutput);
		}
	}
}


//calc new location.
vector V_shareLoc[];
foreach(string oneSimpleShare; sharesSimple){
	// HAVING A POINT RECORDED MANY TIMES IS ***GOOD***. EMERGENT WEIGHTS.
	string S_edges[] = split(oneSimpleShare, ",");
	int I_edges[];
	int JunctionPoints[];
	foreach(string item; S_edges){
		push(I_edges, atoi(item));
	}
	foreach(int edgeindex; I_edges){
		int rawpoints[] = primpoints(0,edgeindex);
		int e0 = rawpoints[0];
		int e1 = rawpoints[-1];
		push(JunctionPoints,e0);
		push(JunctionPoints,e1);	
	}
	vector newLoc = {0,0,0};
	//sum position for all points
	foreach(int point; JunctionPoints){
		vector loc = point(0,"P",point);
		newLoc+=loc;
	}

	newLoc = newLoc/len(JunctionPoints); //AVERAGE
	push(V_shareLoc,newLoc);
}


//Calculate UV Offset. Will need flow direction for +/- multiplier.

//get valid point
//get direction
//get prim

//get beginning or end based on direction
//calculate location difference as float offset.
//store floats in a string array.

string offsets[]; // uv offset for first valid point.
for(int k=0; k<len(sharePrims);k++){
	string offsetCollection = ",";

	string S_thisPrimSet = sharePrims[k];
	string S_thisDirections = shareDirection[k];
	string S_theseClosePoints =  firstValidPoint[k];
	//convert these strings to integer arrays.
	int I_thesePrims[];					foreach(string x;split(S_thisPrimSet,","))			{push(I_thesePrims,				atoi(x)	);}	
	int I_theseDirections[];		foreach(string x;split(S_thisDirections,","))	{push(I_theseDirections,	atoi(x)	);}
	int I_theseClosePoints[];		foreach(string x;split(S_theseClosePoints,",")){push(I_theseClosePoints,	atoi(x)	);}

	//all of these arrays should be 1:1
	for(int x = 0; x<len(I_thesePrims);x++){
		int edg = I_thesePrims[x];
		int edgpnts[] = primpoints(0,edg);
		int dir = I_theseDirections[x];
		int pnt = I_theseClosePoints[x];

		vector thisLoc = point(0,"P",pnt);
		vector newLoc = V_shareLoc[k];
		vector originalLoc;  
		if(dir==1){originalLoc = point(0,"P",edgpnts[0]);}else{originalLoc = point(0,"P",edgpnts[-1]);}


		float od = distance(thisLoc,originalLoc); 
		float nd = distance(thisLoc,newLoc);
		float dd = nd-od;

		string dd_stringified = ftoa(dd);
		offsetCollection += dd_stringified+",";
	}
	push(offsets,offsetCollection);
}

//offset source uv happens when we sweep the curve.
//offset junction happens when we expand the junction.


//SWEEP --LETS DO THIS.
int pointleafleaf[]; //each prim contains 6 entries. start,leaf,leaf,end,leaf,leaf.
int startingPrimCount = nprimitives(0);
printf("starting prim count: %f\\n",startingPrimCount);
for(int sweep=0; sweep<startingPrimCount;sweep++){
	if(find(pointlessPrims,sweep)<0){//if prim is not pointless.
		//for each prim get a list of points that are not too close.
		//mach list with angles.
		int allpoints[] = primpoints(0,sweep);
		int allverts[] = primvertices(0,sweep);
		//create list of points that are not too close.
		int notremoved[];
		int vert_notremoved[];



		foreach(int index; int unfilteredpoint; allpoints){
			if(find(pointsTooClose,unfilteredpoint)<0){
				push(notremoved,unfilteredpoint);
				push(vert_notremoved,allverts[index]);
			}
		}

		float notRemovedAngles[];
		//now we calculate the angles to accompany points that were not removed.
		for(int angleCalc=0; angleCalc<len(notremoved);angleCalc++){
			int thisPoint = notremoved[angleCalc];
			int vert_thisPoint = vert_notremoved[angleCalc];
				
			//Operation Summary:
				//if unfiltered point is not last unfiltered:
				//	angle is this unfiltered to next unfiltered
				//if unfiltered point is last unfiltered:
				//	if unfiltered point is also last general point :
				//		angle is this unfiltered to previous general point  +180Â° 
				//	else:
				//		angle is this unfiltered point to last general point
			if(thisPoint!=notremoved[-1]){//if not last unfiltered.
				vector locationA = point(0,"P",thisPoint);//from
				vector locationB = point(0,"P",notremoved[angleCalc+1]);//to
				float deltax = locationB[0]-locationA[0];
				float deltaz = locationB[2]-locationA[2];
				float atan2result = atan2(deltaz,deltax);
				push(notRemovedAngles,atan2result);
			}else{//is last unfiltered.
				int lastPointInPrim = allpoints[-1];
				if(thisPoint==lastPointInPrim){//this last unfiltered is also last point in prim.
					//angle from second from last to last.
					vector locationA = point(0,"P",allpoints[-2]);//from last-1
					vector locationB = point(0,"P",thisPoint);//to last
					float deltax = locationB[0]-locationA[0];
					float deltaz = locationB[2]-locationA[2];
					float atan2result = atan2(deltaz,deltax);
					push(notRemovedAngles,atan2result);
				}else{
					//angle from last general point.
					int indexOf = find(allpoints,thisPoint);
					int previousGeneral = allpoints[indexOf-1]; 
					vector locationA = point(0,"P",previousGeneral);//from last-1
					vector locationB = point(0,"P",thisPoint);//to last
					float deltax = locationB[0]-locationA[0];
					float deltaz = locationB[2]-locationA[2];
					float atan2result = atan2(deltaz,deltax);
					push(notRemovedAngles,atan2result);
				}
			}
		}

		//CREATE NEW POINTS USING THESE ANGLES.
		int lastCenter = -1;
		int lastRight = -1;
		int lastLeft = -1;
		vector UV_lastCenter;
		vector UV_lastRight;
		vector UV_lastLeft;
		for(int pointIterator = 0; pointIterator<len(notremoved);pointIterator++){
			int   thispoint = notremoved[pointIterator];
			float thisangle = notRemovedAngles[pointIterator];
			vector thisUV = vertex(0,"uv",vert_notremoved[pointIterator]);
			vector thisLocation = point(0,"P",thispoint);
			float m90 = clampAngle(thisangle-pi/2);
			float p90 = clampAngle(thisangle+pi/2);
	
			vector locL= set(
				thisLocation[0]+radius*cos(m90),
				0,
				thisLocation[2]+radius*sin(m90));
			vector locR= set(
				thisLocation[0]+radius*cos(p90),
				0,
				thisLocation[2]+radius*sin(p90));
			int pl = addpoint(0,locL);
			int pr = addpoint(0,locR);
	
			vector upUV = set(
				thisUV[0],
				1,
				0);
			vector downUV = set(
				thisUV[0],
				0,
				0);
			//int pass = setpointattrib(0, "uv", pl, upUV, "set");
			//int pass1 = setpointattrib(0, "uv", pr, downUV, "set");
	
			if(pointIterator==0){//is first
				push(pointleafleaf,thispoint); //pointleafleaf defined on line 349.
				push(pointleafleaf,pl);
				push(pointleafleaf,pr);
			}
			if(pointIterator==len(notremoved)-1){//is last
				push(pointleafleaf,thispoint);
				push(pointleafleaf,pl);
				push(pointleafleaf,pr);
			}
	
			if(lastCenter!=-1){//if we have processed a set already, now we can begin connecting trios.
				int pass;
				int leftface = addprim(0,'poly');
				int v1 = addvertex(0,leftface, lastLeft);
					pass= setvertexattrib(0,"uv",-1,v1,UV_lastLeft,"set");
				int v2 = addvertex(0,leftface, lastCenter);
					pass= setvertexattrib(0,"uv",-1,v2,UV_lastCenter,"set");
				int v3 = addvertex(0,leftface, thispoint);
					pass= setvertexattrib(0,"uv",-1,v3,thisUV,"set");
				int v4 = addvertex(0,leftface, pl);					
					pass= setvertexattrib(0,"uv",-1,v4,upUV,"set");
				int rightface = addprim(0,'poly');
				int v5 = addvertex(0,rightface, lastCenter);
					pass= setvertexattrib(0,"uv",-1,v5,UV_lastCenter,"set");
				int v6 = addvertex(0,rightface, lastRight);
					pass= setvertexattrib(0,"uv",-1,v6,UV_lastRight,"set");
				int v7 = addvertex(0,rightface, pr);					
					pass= setvertexattrib(0,"uv",-1,v7,downUV,"set");
				int v8 = addvertex(0,rightface, thispoint);
					pass= setvertexattrib(0,"uv",-1,v8,thisUV,"set");
			}
			//update last.
				lastCenter = thispoint;
				lastRight = pr;
				lastLeft = pl;
				UV_lastCenter= thisUV; 
				UV_lastLeft  = upUV;
				UV_lastRight = downUV;
			
		}

	}//end bracket if not pointless.
}//end bracket for all primitives.





printf("originalJunctions: %f\\n",		originalJunctions);
printf("pointsTooClose: %f\\n",				pointsTooClose);
printf("pointlessPrims: %f\\n",				pointlessPrims);
printf("specialIntersections: %f\\n",	specialIntersections);
printf("sharesSimple: %f\\n",					sharesSimple);
printf("sharePrims: %f\\n",						sharePrims);
printf("shareDirection: %f\\n",				shareDirection);
printf("firstValidPoint: %f\\n",			firstValidPoint);
printf("V_shareLoc: %f\\n",						V_shareLoc);
printf("offsets: %f\\n",							offsets);
printf("pointleafleaf: %f\\n",				pointleafleaf);

//Create the Junctions.






//INGREDIENTS:
//originalJunctions[];
//pointsTooClose[];
//pointlessPrims[];
//specialIntersections[];
//sharesSimple[]
//sharePrims[];
//shareDirection[];
//firstValidPoint[];
//V_shareLoc[];
//offsets[];
//pointleafleaf[];