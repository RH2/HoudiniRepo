//Checkpoint: 2-9-2019 2:15PM
//CUSTOMEXPAND
float clampAngle(float inputAngle){
    float x = inputAngle/3.14159265;
    x=x%2;
    if(x>1){
        x=-1+(x%1);
    }
    if(x<-1){
        x=1+(x%1);
    }
    x = x*3.14159265;
    return x;
}
void mergeArray(int array1[];int array2[]){
        foreach(int a2; array2){
                if(find(array1,a2)<0){
                        push(array1, a2);
                }
        }
}
float angleBetweenVectors2(vector a; vector b){
        a = normalize(a*{1,0,1});
        b = normalize(b*{1,0,1});
        vector c = normalize(a+b);

        float result = atan2(c[2],c[0]);
        return(result);
}
float sidecheckXZ(vector s; vector e; vector p){ //+=left
        float result = (e[0]-s[0])*(p[2]-s[2])  -  (e[2]-s[2])*(p[0]-s[0]);
        return result;
}

float diameter = 50.0;
float radius = diameter/2;
float pi = 3.14159264;
float tau = 3.14159264*2;


int I_donotsweep[]; //points to exclude from sweeps.
int I_remappedIntersections[]; //datastructure: pointIndex,V_remappedIntersection[i],
vector V_remappedIntersection[]; //new junction locations?


//SETUP--
//FIRST WE REMOVE PRIMITIVES WHO'S FIRST AND LAST VERTEX ARE TOO CLOSE, AND MERGE ENDPOINTS.
int primnum = nprimitives(0);
for(int primI=0;primI<primnum;primI++){
	//get last and first point
	int enumVert = primvertexcount(0,primI);
	int vint = vertexindex(0, primI, 0);				//initial vertex
	int vtrm = vertexindex(0, primI, enumVert-1); //terminal vertex
	vector locint = vertex(0,"P",vint);
	vector loctrm = vertex(0,"P",vtrm);
	vector delta = locint-loctrm;
	float distance = length(delta);
	if(distance<radius){//merge intersections if both ends have more than 3 neighbors, else simply remove.
		int pint = vertexpoint(0,vint);
		int ptrm = vertexpoint(0,vtrm);
		//removeprim(0,primI,1);
		int countint = neighbourcount(0,pint);
		int counttrm = neighbourcount(0,ptrm); // <<WHY ALWAYS ZERO?
		if(countint>=3&&counttrm>=3){ //if both ends are intersections.
			printf("countint>=3&&counttrm>=3");
			vector locaverage = (locint+loctrm/2);//middle location

			int nint[] = neighbours(0,pint);	//FOUR ARRAYS CONTAINING INDEX AND OFFSET INFO.
			float distint[];
			int ntrm[] = neighbours(0,ptrm);
			float disttrm[];

			for(int n = 0; n<len(nint);n++){	//change in distance to new intersection — start junction
				vector locneighbour = point(0,"P",nint[n]);
				vector distoriginal =	length(locneighbour-locint);
				vector distnew			=	length(locneighbour-locaverage);
				float  newoffset = distoriginal-distnew;
				push(distint,newoffset);
			}
			for(int n = 0; n<len(ntrm);n++){	//change in distance to new intersection — end junction
				vector locneighbour = point(0,"P",ntrm[n]);
				vector distoriginal =	length(locneighbour-locint);
				vector distnew			=	length(locneighbour-locaverage);
				float  newoffset = distoriginal-distnew;
				push(disttrm,newoffset);
			}
			
			for(int dp=0; dp < enumVert; dp++){ //mark each point on curve as donotsweep.
				int thisdVertex = vertexindex(0,primI, dp);
				int thisdPoint = vertexpoint(0,thisdVertex);
				if(find(donotsweep,thisdPoint)<0){ //AVOID PUSHING SAME POINT MULTIPLE TIMES.
					push(donotsweep,thisdPoint);
				}
			}

			 
			//array one neightbour-point1, reference-index-to-float-array, neighbour-point, reference-index-to-float-array






		}
	}
}







//SECOND WE CREATE A LOOKUP TABLE OF ALL INTERSECTIONS AND POINTS.
int cect[]; 
string jpoint[];
for(int inipoints=0;inipoints<npoints(0);inipoints++){
	if(neighbourcount(0,inipoints)>2){
		push(cect,inipoints);
	}
}//printf("cect:%f",cect);
//THEN WE ADD POINTS AND LINK THEM TO INTERSECTION POINTS.
	//+MECHANIC FOR REMOVING POINTS IF THEY ARE WITHIN RADIUS OF INTERSECTION. 
	//+MECHANIC FOR JOINING INTERSECTIONS






//GENERATE GEO SWEEPS

//GENERATE GEO INTERSECTION
